******** django-rest-auth - 0.8.1 *******

==>site-packages/rest-auth/views.py
from rest_framework_tracking.mixins import LoggingMixin

class LoginView(LoggingMixin, GenericAPIView):
    #rest of code...

from push_notifications.models import APNSDevice, GCMDevice
class LogoutView(APIView):

    """
    Calls Django logout method and delete the Token object
    assigned to the current User object.

    Accepts/Returns nothing.
    """
    permission_classes = (AllowAny,)

    def post(self, request):
        try:
            token = request.META.get('HTTP_AUTHORIZATION', None)
            if token is not None:
		print "befor delete"
                if GCMDevice.objects.filter(user=request.user, device_id__isnull=False).exists():
                    print "innn GCMDevice"
                    GCMDevice.objects.filter(user=request.user, device_id__isnull=False).delete()
                if APNSDevice.objects.filter(user=request.user).exists():
                    print "innn APNSDevice"
                    APNSDevice.objects.filter(user=request.user).delete()
                print "after delete"
                
                request.user.auth_token.delete()
        except (AttributeError, ObjectDoesNotExist):
            pass

        logout(request)

        return Response({"success": "Successfully logged out."},
                        status=status.HTTP_200_OK)

==>site-packages/rest-auth/registration/views.py
class RegisterView(CreateAPIView):
    def perform_create(self, serializer):
        user = serializer.save(self.request)
        if getattr(settings, 'REST_USE_JWT', False):
            self.token = jwt_encode(user)
        else:
            create_token(self.token_model, user, serializer)

        '''complete_signup(self.request._request, user,
                        allauth_settings.EMAIL_VERIFICATION,
                        None)'''
        user.last_login = None
        user.save()
        return user

****** push-notifications - 1.4.1 **********

==>site-packages/push-notifications/admin.py

class GCMDeviceAdmin(DeviceAdmin):
	"""
	Inherits from DeviceAdmin to handle displaying gcm device as a hex value
	"""
	def device_id_hex(self, obj):
		if connection.vendor in ("mysql", "sqlite") and obj.device_id:
			return hex(obj.device_id).rstrip("L")
		else:
			return obj.device_id
	device_id_hex.short_description = "Device ID"

	list_display = ("__unicode__", "device_id_hex", "user", "active", "date_created")


==>site-packages/push-notifications/api/rest_framework.py

class DeviceSerializerMixin(ModelSerializer):
	class Meta:
		fields = ("id", "user", "name", "registration_id", "device_id", "active", "date_created")
		read_only_fields = ("date_created", )

class APNSDeviceSerializer(ModelSerializer):

	class Meta(DeviceSerializerMixin.Meta):
		model = APNSDevice
		extra_kwargs = {
			'registration_id': {
				'validators': [],
			},
		}

	def validate_registration_id(self, value):
		# iOS device tokens are 256-bit hexadecimal (64 characters). In 2016 Apple is increasing
		# iOS device tokens to 100 bytes hexadecimal (200 characters).

		if hex_re.match(value) is None or len(value) not in (64, 200):
			raise ValidationError("Registration ID (device token) is invalid")

		return value
	
	def create(self, validated_data):
		registration_id = validated_data.get('registration_id', None)
		if registration_id is not None:
			print "registration_id"
			apnsDeviceDelete = APNSDevice.objects.filter(registration_id=registration_id).delete()
			print apnsDeviceDelete
		
		apnsDevice = APNSDevice.objects.create(**validated_data)
		print apnsDevice
		return apnsDevice
	
	def update(self, instance, validated_data):
		registration_id = validated_data.get('registration_id', None)
		if registration_id is not None:
			print "registration_id"
			apnsDeviceDelete = APNSDevice.objects.filter(registration_id=registration_id).delete()
			print apnsDeviceDelete
			
		instance.registration_id = validated_data.get('registration_id', instance.registration_id)
		instance.active = validated_data.get('active', instance.active)
		instance.save()
		return instance
		
class GCMDeviceSerializer(ModelSerializer):
	device_id = HexIntegerField(
		help_text="ANDROID_ID / TelephonyManager.getDeviceId() (e.g: 0x01)",
		style={'input_type': 'text'},
		required=False
	)

	class Meta(DeviceSerializerMixin.Meta):
		model = GCMDevice

		'''extra_kwargs = {
			# Work around an issue with validating the uniqueness of
			# registration ids of up to 4k
			'registration_id': {
				'validators': [
					UniqueValidator(queryset=GCMDevice.objects.all())
				]
			}
		}'''
	
	def create(self, validated_data):
		registration_id = validated_data.get('registration_id', None)
		if registration_id is not None:
			print "registration_id"
			gcmDeviceDelete = GCMDevice.objects.filter(registration_id=registration_id).delete()
			print gcmDeviceDelete
		
		gcmDevice = GCMDevice.objects.create(**validated_data)
		print gcmDevice
		return gcmDevice
	
	def update(self, instance, validated_data):
		registration_id = validated_data.get('registration_id', None)
		if registration_id is not None:
			print "registration_id"
			gcmDeviceDelete = GCMDevice.objects.filter(registration_id=registration_id).delete()
			print gcmDeviceDelete
			
		instance.registration_id = validated_data.get('registration_id', instance.registration_id)
		instance.active = validated_data.get('active', instance.active)
		instance.save()
		return instance

	def validate_device_id(self, value):
		# device ids are 64 bit unsigned values
		if value > UNSIGNED_64BIT_INT_MAX_VALUE:
			raise ValidationError("Device ID is out of range")
		return value


'''class APNSDeviceAuthorizedViewSet(AuthorizedMixin, APNSDeviceViewSet):
	pass'''
class APNSDeviceAuthorizedViewSet(ModelViewSet):
	queryset = APNSDevice.objects.all()
	serializer_class = APNSDeviceSerializer
	permission_classes = (permissions.IsAuthenticated, IsOwner)
	def get_queryset(self):
		# filter all devices to only those belonging to the current user
		return self.queryset.filter(user=self.request.user)
	def perform_create(self, serializer):
		serializer.save(user=self.request.user)

'''class GCMDeviceAuthorizedViewSet(AuthorizedMixin, GCMDeviceViewSet):
	pass'''
class GCMDeviceAuthorizedViewSet(ModelViewSet):
	queryset = GCMDevice.objects.all()
	serializer_class = GCMDeviceSerializer
	permission_classes = (permissions.IsAuthenticated, IsOwner)
	def get_queryset(self):
		# filter all devices to only those belonging to the current user
		return self.queryset.filter(user=self.request.user)
	def perform_create(self, serializer):
		serializer.save(user=self.request.user)
		
==>site-packages/push-notifications/gcm.py
#try:
#	from urllib.request import Request, urlopen
#except ImportError:
	# Python 2 support
from urllib2 import Request, urlopen


==>site-packages/last_modified/last_modified.py

    def process_response(self, request, response):
        print response.__class__.__name__
        if not request.path.startswith('/api/admin/') and not request.path.startswith('/api/rest-auth/') and not request.path.startswith('/api/device/') and not request.path.startswith('/api/api-auth/') and response.__class__.__name__ !='TemplateResponse' and response.__class__.__name__ !='HttpResponseRedirect' and response.__class__.__name__ !='HttpResponsePermanentRedirect' and response.__class__.__name__ !='HttpResponse' and response.__class__.__name__ !='HttpResponseNotFound' and response.__class__.__name__ !='HttpResponseNotModified' and response.__class__.__name__ !='HttpResponseBadRequest' and request.method != "POST":
            value = json.dumps(response.data , use_decimal=True)
            #value = json.dumps(response.data)
            #print value
            newMD5 =  hashlib.md5(value).hexdigest()
            response['Last-Modified'] = newMD5 # http_date(self.last_modified)
            #response['ETag'] = newMD5
            etag = request.META.get('HTTP_IF_MODIFIED_SINCE')
            #etag = request.META.get('HTTP_IF_NONE_MATCH')
            if etag is not None:
                #print response.data
                #print etag
                if etag == newMD5:
                    return HttpResponseNotModified()		
        return response

==>site-packages/django_datatables_view/mixins.py	#for tracking on django debug toolbar
    from rest_framework.response import Response
    class JSONResponseMixin(object):
	def get(self, request, *args, **kwargs):
	    ........
	    #dump = json.dumps(response, cls=LazyEncoder)
	    #return self.render_to_response(dump)
	    return Response(response)

==>change value field size from eav_enumvalue to 254

==>site-packages/rest_framework_tracking/admin.py
#admin.site.register(APIRequestLog, APIRequestLogAdmin)
==>site-packages/rest_framework_tracking/mixins.py
def _clean_data(data):
    '''SENSITIVE_DATA = re.compile('api|token|key|secret|password|signature', re.I)
    CLEANSED_SUBSTITUTE = '********************'
    for key in data:
        if SENSITIVE_DATA.search(key):
            data[key] = CLEANSED_SUBSTITUTE'''
    return data

==>site-packages/rest_framework_tracking/models.py
class BaseAPIRequestLog(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, null=True, blank=True)



